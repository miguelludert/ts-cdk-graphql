{
  "rootStack": {
    "AWSTemplateFormatVersion": "2010-09-09",
    "Description": "An auto-generated nested stack.",
    "Metadata": {},
    "Parameters": {
      "DynamoDBModelTableReadIOPS": {
        "Type": "Number",
        "Description": "The number of read IOPS the table should support.",
        "Default": 5
      },
      "DynamoDBModelTableWriteIOPS": {
        "Type": "Number",
        "Description": "The number of write IOPS the table should support.",
        "Default": 5
      },
      "DynamoDBBillingMode": {
        "Type": "String",
        "Description": "Configure @model types to create DynamoDB tables with PAY_PER_REQUEST or PROVISIONED billing modes.",
        "Default": "PAY_PER_REQUEST",
        "AllowedValues": [
          "PAY_PER_REQUEST",
          "PROVISIONED"
        ]
      },
      "DynamoDBEnablePointInTimeRecovery": {
        "Type": "String",
        "Description": "Whether to enable Point in Time Recovery on the table",
        "Default": "false",
        "AllowedValues": [
          "true",
          "false"
        ]
      },
      "DynamoDBEnableServerSideEncryption": {
        "Type": "String",
        "Description": "Enable server side encryption powered by KMS.",
        "Default": "true",
        "AllowedValues": [
          "true",
          "false"
        ]
      },
      "env": {
        "Type": "String",
        "Description": "The environment name. e.g. Dev, Test, or Production",
        "Default": "NONE"
      },
      "S3DeploymentBucket": {
        "Type": "String",
        "Description": "The S3 bucket containing all deployment assets for the project."
      },
      "S3DeploymentRootKey": {
        "Type": "String",
        "Description": "An S3 key relative to the S3DeploymentBucket that points to the root of the deployment directory."
      }
    },
    "Resources": {
      "GraphQLAPI": {
        "Type": "AWS::AppSync::GraphQLApi",
        "Properties": {
          "Name": {
            "Fn::If": [
              "HasEnvironmentParameter",
              {
                "Fn::Join": [
                  "-",
                  [
                    {
                      "Ref": "AppSyncApiName"
                    },
                    {
                      "Ref": "env"
                    }
                  ]
                ]
              },
              {
                "Ref": "AppSyncApiName"
              }
            ]
          },
          "AuthenticationType": "API_KEY"
        }
      },
      "GraphQLSchema": {
        "Type": "AWS::AppSync::GraphQLSchema",
        "Properties": {
          "ApiId": {
            "Fn::GetAtt": [
              "GraphQLAPI",
              "ApiId"
            ]
          },
          "DefinitionS3Location": {
            "Fn::Sub": [
              "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/schema.graphql",
              {
                "S3DeploymentBucket": {
                  "Ref": "S3DeploymentBucket"
                },
                "S3DeploymentRootKey": {
                  "Ref": "S3DeploymentRootKey"
                }
              }
            ]
          }
        }
      },
      "Blog": {
        "Type": "AWS::CloudFormation::Stack",
        "Properties": {
          "Parameters": {
            "AppSyncApiId": {
              "Fn::GetAtt": [
                "GraphQLAPI",
                "ApiId"
              ]
            },
            "DynamoDBModelTableReadIOPS": {
              "Ref": "DynamoDBModelTableReadIOPS"
            },
            "DynamoDBModelTableWriteIOPS": {
              "Ref": "DynamoDBModelTableWriteIOPS"
            },
            "DynamoDBBillingMode": {
              "Ref": "DynamoDBBillingMode"
            },
            "DynamoDBEnablePointInTimeRecovery": {
              "Ref": "DynamoDBEnablePointInTimeRecovery"
            },
            "DynamoDBEnableServerSideEncryption": {
              "Ref": "DynamoDBEnableServerSideEncryption"
            },
            "env": {
              "Ref": "env"
            },
            "S3DeploymentBucket": {
              "Ref": "S3DeploymentBucket"
            },
            "S3DeploymentRootKey": {
              "Ref": "S3DeploymentRootKey"
            },
            "GetAttGraphQLAPIApiId": {
              "Fn::GetAtt": [
                "GraphQLAPI",
                "ApiId"
              ]
            }
          },
          "TemplateURL": {
            "Fn::Join": [
              "/",
              [
                "https://s3.amazonaws.com",
                {
                  "Ref": "S3DeploymentBucket"
                },
                {
                  "Ref": "S3DeploymentRootKey"
                },
                "stacks",
                "Blog.json"
              ]
            ]
          }
        },
        "DependsOn": [
          "GraphQLSchema"
        ]
      },
      "BlogPost": {
        "Type": "AWS::CloudFormation::Stack",
        "Properties": {
          "Parameters": {
            "AppSyncApiId": {
              "Fn::GetAtt": [
                "GraphQLAPI",
                "ApiId"
              ]
            },
            "DynamoDBModelTableReadIOPS": {
              "Ref": "DynamoDBModelTableReadIOPS"
            },
            "DynamoDBModelTableWriteIOPS": {
              "Ref": "DynamoDBModelTableWriteIOPS"
            },
            "DynamoDBBillingMode": {
              "Ref": "DynamoDBBillingMode"
            },
            "DynamoDBEnablePointInTimeRecovery": {
              "Ref": "DynamoDBEnablePointInTimeRecovery"
            },
            "DynamoDBEnableServerSideEncryption": {
              "Ref": "DynamoDBEnableServerSideEncryption"
            },
            "env": {
              "Ref": "env"
            },
            "S3DeploymentBucket": {
              "Ref": "S3DeploymentBucket"
            },
            "S3DeploymentRootKey": {
              "Ref": "S3DeploymentRootKey"
            },
            "GetAttGraphQLAPIApiId": {
              "Fn::GetAtt": [
                "GraphQLAPI",
                "ApiId"
              ]
            }
          },
          "TemplateURL": {
            "Fn::Join": [
              "/",
              [
                "https://s3.amazonaws.com",
                {
                  "Ref": "S3DeploymentBucket"
                },
                {
                  "Ref": "S3DeploymentRootKey"
                },
                "stacks",
                "BlogPost.json"
              ]
            ]
          }
        },
        "DependsOn": [
          "GraphQLSchema"
        ]
      },
      "Comment": {
        "Type": "AWS::CloudFormation::Stack",
        "Properties": {
          "Parameters": {
            "AppSyncApiId": {
              "Fn::GetAtt": [
                "GraphQLAPI",
                "ApiId"
              ]
            },
            "DynamoDBModelTableReadIOPS": {
              "Ref": "DynamoDBModelTableReadIOPS"
            },
            "DynamoDBModelTableWriteIOPS": {
              "Ref": "DynamoDBModelTableWriteIOPS"
            },
            "DynamoDBBillingMode": {
              "Ref": "DynamoDBBillingMode"
            },
            "DynamoDBEnablePointInTimeRecovery": {
              "Ref": "DynamoDBEnablePointInTimeRecovery"
            },
            "DynamoDBEnableServerSideEncryption": {
              "Ref": "DynamoDBEnableServerSideEncryption"
            },
            "env": {
              "Ref": "env"
            },
            "S3DeploymentBucket": {
              "Ref": "S3DeploymentBucket"
            },
            "S3DeploymentRootKey": {
              "Ref": "S3DeploymentRootKey"
            },
            "GetAttGraphQLAPIApiId": {
              "Fn::GetAtt": [
                "GraphQLAPI",
                "ApiId"
              ]
            }
          },
          "TemplateURL": {
            "Fn::Join": [
              "/",
              [
                "https://s3.amazonaws.com",
                {
                  "Ref": "S3DeploymentBucket"
                },
                {
                  "Ref": "S3DeploymentRootKey"
                },
                "stacks",
                "Comment.json"
              ]
            ]
          }
        },
        "DependsOn": [
          "GraphQLSchema"
        ]
      },
      "FunctionDirectiveStack": {
        "Type": "AWS::CloudFormation::Stack",
        "Properties": {
          "Parameters": {
            "AppSyncApiId": {
              "Fn::GetAtt": [
                "GraphQLAPI",
                "ApiId"
              ]
            },
            "DynamoDBModelTableReadIOPS": {
              "Ref": "DynamoDBModelTableReadIOPS"
            },
            "DynamoDBModelTableWriteIOPS": {
              "Ref": "DynamoDBModelTableWriteIOPS"
            },
            "DynamoDBBillingMode": {
              "Ref": "DynamoDBBillingMode"
            },
            "DynamoDBEnablePointInTimeRecovery": {
              "Ref": "DynamoDBEnablePointInTimeRecovery"
            },
            "DynamoDBEnableServerSideEncryption": {
              "Ref": "DynamoDBEnableServerSideEncryption"
            },
            "env": {
              "Ref": "env"
            },
            "S3DeploymentBucket": {
              "Ref": "S3DeploymentBucket"
            },
            "S3DeploymentRootKey": {
              "Ref": "S3DeploymentRootKey"
            },
            "GetAttGraphQLAPIApiId": {
              "Fn::GetAtt": [
                "GraphQLAPI",
                "ApiId"
              ]
            }
          },
          "TemplateURL": {
            "Fn::Join": [
              "/",
              [
                "https://s3.amazonaws.com",
                {
                  "Ref": "S3DeploymentBucket"
                },
                {
                  "Ref": "S3DeploymentRootKey"
                },
                "stacks",
                "FunctionDirectiveStack.json"
              ]
            ]
          }
        },
        "DependsOn": [
          "GraphQLSchema"
        ]
      }
    },
    "Outputs": {
      "GraphQLAPIIdOutput": {
        "Description": "Your GraphQL API ID.",
        "Value": {
          "Fn::GetAtt": [
            "GraphQLAPI",
            "ApiId"
          ]
        },
        "Export": {
          "Name": {
            "Fn::Join": [
              ":",
              [
                {
                  "Ref": "AWS::StackName"
                },
                "GraphQLApiId"
              ]
            ]
          }
        }
      },
      "GraphQLAPIEndpointOutput": {
        "Description": "Your GraphQL API endpoint.",
        "Value": {
          "Fn::GetAtt": [
            "GraphQLAPI",
            "GraphQLUrl"
          ]
        },
        "Export": {
          "Name": {
            "Fn::Join": [
              ":",
              [
                {
                  "Ref": "AWS::StackName"
                },
                "GraphQLApiEndpoint"
              ]
            ]
          }
        }
      }
    },
    "Mappings": {},
    "Conditions": {
      "ShouldUsePayPerRequestBilling": {
        "Fn::Equals": [
          {
            "Ref": "DynamoDBBillingMode"
          },
          "PAY_PER_REQUEST"
        ]
      },
      "ShouldUsePointInTimeRecovery": {
        "Fn::Equals": [
          {
            "Ref": "DynamoDBEnablePointInTimeRecovery"
          },
          "true"
        ]
      },
      "ShouldUseServerSideEncryption": {
        "Fn::Equals": [
          {
            "Ref": "DynamoDBEnableServerSideEncryption"
          },
          "true"
        ]
      },
      "HasEnvironmentParameter": {
        "Fn::Not": [
          {
            "Fn::Equals": [
              {
                "Ref": "env"
              },
              "NONE"
            ]
          }
        ]
      }
    }
  },
  "stacks": {
    "Blog": {
      "AWSTemplateFormatVersion": "2010-09-09",
      "Description": "An auto-generated nested stack.",
      "Metadata": {},
      "Parameters": {
        "DynamoDBModelTableReadIOPS": {
          "Type": "Number",
          "Description": "The number of read IOPS the table should support.",
          "Default": 5
        },
        "DynamoDBModelTableWriteIOPS": {
          "Type": "Number",
          "Description": "The number of write IOPS the table should support.",
          "Default": 5
        },
        "DynamoDBBillingMode": {
          "Type": "String",
          "Description": "Configure @model types to create DynamoDB tables with PAY_PER_REQUEST or PROVISIONED billing modes.",
          "Default": "PAY_PER_REQUEST",
          "AllowedValues": [
            "PAY_PER_REQUEST",
            "PROVISIONED"
          ]
        },
        "DynamoDBEnablePointInTimeRecovery": {
          "Type": "String",
          "Description": "Whether to enable Point in Time Recovery on the table",
          "Default": "false",
          "AllowedValues": [
            "true",
            "false"
          ]
        },
        "DynamoDBEnableServerSideEncryption": {
          "Type": "String",
          "Description": "Enable server side encryption powered by KMS.",
          "Default": "true",
          "AllowedValues": [
            "true",
            "false"
          ]
        },
        "env": {
          "Type": "String",
          "Description": "The environment name. e.g. Dev, Test, or Production",
          "Default": "NONE"
        },
        "S3DeploymentBucket": {
          "Type": "String",
          "Description": "The S3 bucket containing all deployment assets for the project."
        },
        "S3DeploymentRootKey": {
          "Type": "String",
          "Description": "An S3 key relative to the S3DeploymentBucket that points to the root of the deployment directory."
        },
        "AppSyncApiId": {
          "Type": "String",
          "Description": "The id of the AppSync API associated with this project."
        },
        "GetAttGraphQLAPIApiId": {
          "Type": "String",
          "Description": "Auto-generated parameter that forwards Fn.GetAtt(GraphQLAPI, ApiId) through to nested stacks."
        }
      },
      "Resources": {
        "BlogTable": {
          "Type": "AWS::DynamoDB::Table",
          "Properties": {
            "TableName": {
              "Fn::If": [
                "HasEnvironmentParameter",
                {
                  "Fn::Join": [
                    "-",
                    [
                      "Blog",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      },
                      {
                        "Ref": "env"
                      }
                    ]
                  ]
                },
                {
                  "Fn::Join": [
                    "-",
                    [
                      "Blog",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      }
                    ]
                  ]
                }
              ]
            },
            "KeySchema": [
              {
                "AttributeName": "blogId",
                "KeyType": "HASH"
              }
            ],
            "AttributeDefinitions": [
              {
                "AttributeName": "blogId",
                "AttributeType": "S"
              }
            ],
            "StreamSpecification": {
              "StreamViewType": "NEW_AND_OLD_IMAGES"
            },
            "BillingMode": {
              "Fn::If": [
                "ShouldUsePayPerRequestBilling",
                "PAY_PER_REQUEST",
                {
                  "Ref": "AWS::NoValue"
                }
              ]
            },
            "ProvisionedThroughput": {
              "Fn::If": [
                "ShouldUsePayPerRequestBilling",
                {
                  "Ref": "AWS::NoValue"
                },
                {
                  "ReadCapacityUnits": {
                    "Ref": "DynamoDBModelTableReadIOPS"
                  },
                  "WriteCapacityUnits": {
                    "Ref": "DynamoDBModelTableWriteIOPS"
                  }
                }
              ]
            },
            "SSESpecification": {
              "SSEEnabled": {
                "Fn::If": [
                  "ShouldUseServerSideEncryption",
                  true,
                  false
                ]
              }
            },
            "PointInTimeRecoverySpecification": {
              "Fn::If": [
                "ShouldUsePointInTimeRecovery",
                {
                  "PointInTimeRecoveryEnabled": true
                },
                {
                  "Ref": "AWS::NoValue"
                }
              ]
            }
          },
          "DeletionPolicy": "Delete"
        },
        "BlogIAMRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "RoleName": {
              "Fn::If": [
                "HasEnvironmentParameter",
                {
                  "Fn::Join": [
                    "-",
                    [
                      "Blog5a0ed0",
                      "role",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      },
                      {
                        "Ref": "env"
                      }
                    ]
                  ]
                },
                {
                  "Fn::Join": [
                    "-",
                    [
                      "Blog0e5d83",
                      "role",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      }
                    ]
                  ]
                }
              ]
            },
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "appsync.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "Policies": [
              {
                "PolicyName": "DynamoDBAccess",
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Action": [
                        "dynamodb:BatchGetItem",
                        "dynamodb:BatchWriteItem",
                        "dynamodb:PutItem",
                        "dynamodb:DeleteItem",
                        "dynamodb:GetItem",
                        "dynamodb:Scan",
                        "dynamodb:Query",
                        "dynamodb:UpdateItem"
                      ],
                      "Resource": [
                        {
                          "Fn::Sub": [
                            "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}",
                            {
                              "tablename": {
                                "Fn::If": [
                                  "HasEnvironmentParameter",
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "Blog",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        },
                                        {
                                          "Ref": "env"
                                        }
                                      ]
                                    ]
                                  },
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "Blog",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        }
                                      ]
                                    ]
                                  }
                                ]
                              }
                            }
                          ]
                        },
                        {
                          "Fn::Sub": [
                            "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}/*",
                            {
                              "tablename": {
                                "Fn::If": [
                                  "HasEnvironmentParameter",
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "Blog",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        },
                                        {
                                          "Ref": "env"
                                        }
                                      ]
                                    ]
                                  },
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "Blog",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        }
                                      ]
                                    ]
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              }
            ]
          }
        },
        "BlogDataSource": {
          "Type": "AWS::AppSync::DataSource",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "Name": "BlogTable",
            "Type": "AMAZON_DYNAMODB",
            "ServiceRoleArn": {
              "Fn::GetAtt": [
                "BlogIAMRole",
                "Arn"
              ]
            },
            "DynamoDBConfig": {
              "AwsRegion": {
                "Ref": "AWS::Region"
              },
              "TableName": {
                "Fn::If": [
                  "HasEnvironmentParameter",
                  {
                    "Fn::Join": [
                      "-",
                      [
                        "Blog",
                        {
                          "Ref": "GetAttGraphQLAPIApiId"
                        },
                        {
                          "Ref": "env"
                        }
                      ]
                    ]
                  },
                  {
                    "Fn::Join": [
                      "-",
                      [
                        "Blog",
                        {
                          "Ref": "GetAttGraphQLAPIApiId"
                        }
                      ]
                    ]
                  }
                ]
              }
            }
          },
          "DependsOn": [
            "BlogIAMRole"
          ]
        },
        "GetBlogResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogDataSource",
                "Name"
              ]
            },
            "FieldName": "getBlog",
            "TypeName": "Query",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "getBlog",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "getBlog",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "ListBlogResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogDataSource",
                "Name"
              ]
            },
            "FieldName": "listBlogs",
            "TypeName": "Query",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "listBlogs",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "listBlogs",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "CreateBlogResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogDataSource",
                "Name"
              ]
            },
            "FieldName": "createBlog",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "createBlog",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "createBlog",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "UpdateBlogResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogDataSource",
                "Name"
              ]
            },
            "FieldName": "updateBlog",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "updateBlog",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "updateBlog",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "DeleteBlogResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogDataSource",
                "Name"
              ]
            },
            "FieldName": "deleteBlog",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "deleteBlog",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "deleteBlog",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        }
      },
      "Outputs": {
        "GetAttBlogTableStreamArn": {
          "Description": "Your DynamoDB table StreamArn.",
          "Value": {
            "Fn::GetAtt": [
              "BlogTable",
              "StreamArn"
            ]
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "BlogTable",
                  "StreamArn"
                ]
              ]
            }
          }
        },
        "GetAttBlogDataSourceName": {
          "Description": "Your model DataSource name.",
          "Value": {
            "Fn::GetAtt": [
              "BlogDataSource",
              "Name"
            ]
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "BlogDataSource",
                  "Name"
                ]
              ]
            }
          }
        },
        "GetAttBlogTableName": {
          "Description": "Your DynamoDB table name.",
          "Value": {
            "Ref": "BlogTable"
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "BlogTable",
                  "Name"
                ]
              ]
            }
          }
        }
      },
      "Mappings": {},
      "Conditions": {
        "ShouldUsePayPerRequestBilling": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBBillingMode"
            },
            "PAY_PER_REQUEST"
          ]
        },
        "ShouldUsePointInTimeRecovery": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBEnablePointInTimeRecovery"
            },
            "true"
          ]
        },
        "ShouldUseServerSideEncryption": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBEnableServerSideEncryption"
            },
            "true"
          ]
        },
        "HasEnvironmentParameter": {
          "Fn::Not": [
            {
              "Fn::Equals": [
                {
                  "Ref": "env"
                },
                "NONE"
              ]
            }
          ]
        }
      }
    },
    "BlogPost": {
      "AWSTemplateFormatVersion": "2010-09-09",
      "Description": "An auto-generated nested stack.",
      "Metadata": {},
      "Parameters": {
        "DynamoDBModelTableReadIOPS": {
          "Type": "Number",
          "Description": "The number of read IOPS the table should support.",
          "Default": 5
        },
        "DynamoDBModelTableWriteIOPS": {
          "Type": "Number",
          "Description": "The number of write IOPS the table should support.",
          "Default": 5
        },
        "DynamoDBBillingMode": {
          "Type": "String",
          "Description": "Configure @model types to create DynamoDB tables with PAY_PER_REQUEST or PROVISIONED billing modes.",
          "Default": "PAY_PER_REQUEST",
          "AllowedValues": [
            "PAY_PER_REQUEST",
            "PROVISIONED"
          ]
        },
        "DynamoDBEnablePointInTimeRecovery": {
          "Type": "String",
          "Description": "Whether to enable Point in Time Recovery on the table",
          "Default": "false",
          "AllowedValues": [
            "true",
            "false"
          ]
        },
        "DynamoDBEnableServerSideEncryption": {
          "Type": "String",
          "Description": "Enable server side encryption powered by KMS.",
          "Default": "true",
          "AllowedValues": [
            "true",
            "false"
          ]
        },
        "env": {
          "Type": "String",
          "Description": "The environment name. e.g. Dev, Test, or Production",
          "Default": "NONE"
        },
        "S3DeploymentBucket": {
          "Type": "String",
          "Description": "The S3 bucket containing all deployment assets for the project."
        },
        "S3DeploymentRootKey": {
          "Type": "String",
          "Description": "An S3 key relative to the S3DeploymentBucket that points to the root of the deployment directory."
        },
        "AppSyncApiId": {
          "Type": "String",
          "Description": "The id of the AppSync API associated with this project."
        },
        "GetAttGraphQLAPIApiId": {
          "Type": "String",
          "Description": "Auto-generated parameter that forwards Fn.GetAtt(GraphQLAPI, ApiId) through to nested stacks."
        }
      },
      "Resources": {
        "BlogPostTable": {
          "Type": "AWS::DynamoDB::Table",
          "Properties": {
            "TableName": {
              "Fn::If": [
                "HasEnvironmentParameter",
                {
                  "Fn::Join": [
                    "-",
                    [
                      "BlogPost",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      },
                      {
                        "Ref": "env"
                      }
                    ]
                  ]
                },
                {
                  "Fn::Join": [
                    "-",
                    [
                      "BlogPost",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      }
                    ]
                  ]
                }
              ]
            },
            "KeySchema": [
              {
                "AttributeName": "blogId",
                "KeyType": "HASH"
              },
              {
                "AttributeName": "blogPostId",
                "KeyType": "RANGE"
              }
            ],
            "AttributeDefinitions": [
              {
                "AttributeName": "blogId",
                "AttributeType": "S"
              },
              {
                "AttributeName": "blogPostId",
                "AttributeType": "S"
              }
            ],
            "StreamSpecification": {
              "StreamViewType": "NEW_AND_OLD_IMAGES"
            },
            "BillingMode": {
              "Fn::If": [
                "ShouldUsePayPerRequestBilling",
                "PAY_PER_REQUEST",
                {
                  "Ref": "AWS::NoValue"
                }
              ]
            },
            "ProvisionedThroughput": {
              "Fn::If": [
                "ShouldUsePayPerRequestBilling",
                {
                  "Ref": "AWS::NoValue"
                },
                {
                  "ReadCapacityUnits": {
                    "Ref": "DynamoDBModelTableReadIOPS"
                  },
                  "WriteCapacityUnits": {
                    "Ref": "DynamoDBModelTableWriteIOPS"
                  }
                }
              ]
            },
            "SSESpecification": {
              "SSEEnabled": {
                "Fn::If": [
                  "ShouldUseServerSideEncryption",
                  true,
                  false
                ]
              }
            },
            "PointInTimeRecoverySpecification": {
              "Fn::If": [
                "ShouldUsePointInTimeRecovery",
                {
                  "PointInTimeRecoveryEnabled": true
                },
                {
                  "Ref": "AWS::NoValue"
                }
              ]
            }
          },
          "DeletionPolicy": "Delete"
        },
        "BlogPostIAMRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "RoleName": {
              "Fn::If": [
                "HasEnvironmentParameter",
                {
                  "Fn::Join": [
                    "-",
                    [
                      "BlogPoste8073b",
                      "role",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      },
                      {
                        "Ref": "env"
                      }
                    ]
                  ]
                },
                {
                  "Fn::Join": [
                    "-",
                    [
                      "BlogPost6d6095",
                      "role",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      }
                    ]
                  ]
                }
              ]
            },
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "appsync.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "Policies": [
              {
                "PolicyName": "DynamoDBAccess",
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Action": [
                        "dynamodb:BatchGetItem",
                        "dynamodb:BatchWriteItem",
                        "dynamodb:PutItem",
                        "dynamodb:DeleteItem",
                        "dynamodb:GetItem",
                        "dynamodb:Scan",
                        "dynamodb:Query",
                        "dynamodb:UpdateItem"
                      ],
                      "Resource": [
                        {
                          "Fn::Sub": [
                            "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}",
                            {
                              "tablename": {
                                "Fn::If": [
                                  "HasEnvironmentParameter",
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "BlogPost",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        },
                                        {
                                          "Ref": "env"
                                        }
                                      ]
                                    ]
                                  },
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "BlogPost",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        }
                                      ]
                                    ]
                                  }
                                ]
                              }
                            }
                          ]
                        },
                        {
                          "Fn::Sub": [
                            "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}/*",
                            {
                              "tablename": {
                                "Fn::If": [
                                  "HasEnvironmentParameter",
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "BlogPost",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        },
                                        {
                                          "Ref": "env"
                                        }
                                      ]
                                    ]
                                  },
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "BlogPost",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        }
                                      ]
                                    ]
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              }
            ]
          }
        },
        "BlogPostDataSource": {
          "Type": "AWS::AppSync::DataSource",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "Name": "BlogPostTable",
            "Type": "AMAZON_DYNAMODB",
            "ServiceRoleArn": {
              "Fn::GetAtt": [
                "BlogPostIAMRole",
                "Arn"
              ]
            },
            "DynamoDBConfig": {
              "AwsRegion": {
                "Ref": "AWS::Region"
              },
              "TableName": {
                "Fn::If": [
                  "HasEnvironmentParameter",
                  {
                    "Fn::Join": [
                      "-",
                      [
                        "BlogPost",
                        {
                          "Ref": "GetAttGraphQLAPIApiId"
                        },
                        {
                          "Ref": "env"
                        }
                      ]
                    ]
                  },
                  {
                    "Fn::Join": [
                      "-",
                      [
                        "BlogPost",
                        {
                          "Ref": "GetAttGraphQLAPIApiId"
                        }
                      ]
                    ]
                  }
                ]
              }
            }
          },
          "DependsOn": [
            "BlogPostIAMRole"
          ]
        },
        "GetBlogPostResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogPostDataSource",
                "Name"
              ]
            },
            "FieldName": "getBlogPost",
            "TypeName": "Query",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "getBlogPost",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "getBlogPost",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "ListBlogPostResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogPostDataSource",
                "Name"
              ]
            },
            "FieldName": "listBlogPosts",
            "TypeName": "Query",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "listBlogPosts",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "listBlogPosts",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "CreateBlogPostResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogPostDataSource",
                "Name"
              ]
            },
            "FieldName": "createBlogPost",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "createBlogPost",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "createBlogPost",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "UpdateBlogPostResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogPostDataSource",
                "Name"
              ]
            },
            "FieldName": "updateBlogPost",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "updateBlogPost",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "updateBlogPost",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "DeleteBlogPostResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "BlogPostDataSource",
                "Name"
              ]
            },
            "FieldName": "deleteBlogPost",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "deleteBlogPost",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "deleteBlogPost",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        }
      },
      "Outputs": {
        "GetAttBlogPostTableStreamArn": {
          "Description": "Your DynamoDB table StreamArn.",
          "Value": {
            "Fn::GetAtt": [
              "BlogPostTable",
              "StreamArn"
            ]
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "BlogPostTable",
                  "StreamArn"
                ]
              ]
            }
          }
        },
        "GetAttBlogPostDataSourceName": {
          "Description": "Your model DataSource name.",
          "Value": {
            "Fn::GetAtt": [
              "BlogPostDataSource",
              "Name"
            ]
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "BlogPostDataSource",
                  "Name"
                ]
              ]
            }
          }
        },
        "GetAttBlogPostTableName": {
          "Description": "Your DynamoDB table name.",
          "Value": {
            "Ref": "BlogPostTable"
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "BlogPostTable",
                  "Name"
                ]
              ]
            }
          }
        }
      },
      "Mappings": {},
      "Conditions": {
        "ShouldUsePayPerRequestBilling": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBBillingMode"
            },
            "PAY_PER_REQUEST"
          ]
        },
        "ShouldUsePointInTimeRecovery": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBEnablePointInTimeRecovery"
            },
            "true"
          ]
        },
        "ShouldUseServerSideEncryption": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBEnableServerSideEncryption"
            },
            "true"
          ]
        },
        "HasEnvironmentParameter": {
          "Fn::Not": [
            {
              "Fn::Equals": [
                {
                  "Ref": "env"
                },
                "NONE"
              ]
            }
          ]
        }
      }
    },
    "Comment": {
      "AWSTemplateFormatVersion": "2010-09-09",
      "Description": "An auto-generated nested stack.",
      "Metadata": {},
      "Parameters": {
        "DynamoDBModelTableReadIOPS": {
          "Type": "Number",
          "Description": "The number of read IOPS the table should support.",
          "Default": 5
        },
        "DynamoDBModelTableWriteIOPS": {
          "Type": "Number",
          "Description": "The number of write IOPS the table should support.",
          "Default": 5
        },
        "DynamoDBBillingMode": {
          "Type": "String",
          "Description": "Configure @model types to create DynamoDB tables with PAY_PER_REQUEST or PROVISIONED billing modes.",
          "Default": "PAY_PER_REQUEST",
          "AllowedValues": [
            "PAY_PER_REQUEST",
            "PROVISIONED"
          ]
        },
        "DynamoDBEnablePointInTimeRecovery": {
          "Type": "String",
          "Description": "Whether to enable Point in Time Recovery on the table",
          "Default": "false",
          "AllowedValues": [
            "true",
            "false"
          ]
        },
        "DynamoDBEnableServerSideEncryption": {
          "Type": "String",
          "Description": "Enable server side encryption powered by KMS.",
          "Default": "true",
          "AllowedValues": [
            "true",
            "false"
          ]
        },
        "env": {
          "Type": "String",
          "Description": "The environment name. e.g. Dev, Test, or Production",
          "Default": "NONE"
        },
        "S3DeploymentBucket": {
          "Type": "String",
          "Description": "The S3 bucket containing all deployment assets for the project."
        },
        "S3DeploymentRootKey": {
          "Type": "String",
          "Description": "An S3 key relative to the S3DeploymentBucket that points to the root of the deployment directory."
        },
        "AppSyncApiId": {
          "Type": "String",
          "Description": "The id of the AppSync API associated with this project."
        },
        "GetAttGraphQLAPIApiId": {
          "Type": "String",
          "Description": "Auto-generated parameter that forwards Fn.GetAtt(GraphQLAPI, ApiId) through to nested stacks."
        }
      },
      "Resources": {
        "CommentTable": {
          "Type": "AWS::DynamoDB::Table",
          "Properties": {
            "TableName": {
              "Fn::If": [
                "HasEnvironmentParameter",
                {
                  "Fn::Join": [
                    "-",
                    [
                      "Comment",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      },
                      {
                        "Ref": "env"
                      }
                    ]
                  ]
                },
                {
                  "Fn::Join": [
                    "-",
                    [
                      "Comment",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      }
                    ]
                  ]
                }
              ]
            },
            "KeySchema": [
              {
                "AttributeName": "blogPostId",
                "KeyType": "HASH"
              },
              {
                "AttributeName": "commentId",
                "KeyType": "RANGE"
              }
            ],
            "AttributeDefinitions": [
              {
                "AttributeName": "blogPostId",
                "AttributeType": "S"
              },
              {
                "AttributeName": "commentId",
                "AttributeType": "S"
              },
              {
                "AttributeName": "publishDate",
                "AttributeType": "N"
              }
            ],
            "StreamSpecification": {
              "StreamViewType": "NEW_AND_OLD_IMAGES"
            },
            "BillingMode": {
              "Fn::If": [
                "ShouldUsePayPerRequestBilling",
                "PAY_PER_REQUEST",
                {
                  "Ref": "AWS::NoValue"
                }
              ]
            },
            "ProvisionedThroughput": {
              "Fn::If": [
                "ShouldUsePayPerRequestBilling",
                {
                  "Ref": "AWS::NoValue"
                },
                {
                  "ReadCapacityUnits": {
                    "Ref": "DynamoDBModelTableReadIOPS"
                  },
                  "WriteCapacityUnits": {
                    "Ref": "DynamoDBModelTableWriteIOPS"
                  }
                }
              ]
            },
            "SSESpecification": {
              "SSEEnabled": {
                "Fn::If": [
                  "ShouldUseServerSideEncryption",
                  true,
                  false
                ]
              }
            },
            "PointInTimeRecoverySpecification": {
              "Fn::If": [
                "ShouldUsePointInTimeRecovery",
                {
                  "PointInTimeRecoveryEnabled": true
                },
                {
                  "Ref": "AWS::NoValue"
                }
              ]
            },
            "GlobalSecondaryIndexes": [
              {
                "IndexName": "byPublishDate",
                "KeySchema": [
                  {
                    "AttributeName": "publishDate",
                    "KeyType": "HASH"
                  }
                ],
                "Projection": {
                  "ProjectionType": "ALL"
                },
                "ProvisionedThroughput": {
                  "Fn::If": [
                    "ShouldUsePayPerRequestBilling",
                    {
                      "Ref": "AWS::NoValue"
                    },
                    {
                      "ReadCapacityUnits": {
                        "Ref": "DynamoDBModelTableReadIOPS"
                      },
                      "WriteCapacityUnits": {
                        "Ref": "DynamoDBModelTableWriteIOPS"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "DeletionPolicy": "Delete"
        },
        "CommentIAMRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "RoleName": {
              "Fn::If": [
                "HasEnvironmentParameter",
                {
                  "Fn::Join": [
                    "-",
                    [
                      "Comment82f00f",
                      "role",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      },
                      {
                        "Ref": "env"
                      }
                    ]
                  ]
                },
                {
                  "Fn::Join": [
                    "-",
                    [
                      "Comment8cf4ef",
                      "role",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      }
                    ]
                  ]
                }
              ]
            },
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "appsync.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "Policies": [
              {
                "PolicyName": "DynamoDBAccess",
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Action": [
                        "dynamodb:BatchGetItem",
                        "dynamodb:BatchWriteItem",
                        "dynamodb:PutItem",
                        "dynamodb:DeleteItem",
                        "dynamodb:GetItem",
                        "dynamodb:Scan",
                        "dynamodb:Query",
                        "dynamodb:UpdateItem"
                      ],
                      "Resource": [
                        {
                          "Fn::Sub": [
                            "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}",
                            {
                              "tablename": {
                                "Fn::If": [
                                  "HasEnvironmentParameter",
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "Comment",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        },
                                        {
                                          "Ref": "env"
                                        }
                                      ]
                                    ]
                                  },
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "Comment",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        }
                                      ]
                                    ]
                                  }
                                ]
                              }
                            }
                          ]
                        },
                        {
                          "Fn::Sub": [
                            "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${tablename}/*",
                            {
                              "tablename": {
                                "Fn::If": [
                                  "HasEnvironmentParameter",
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "Comment",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        },
                                        {
                                          "Ref": "env"
                                        }
                                      ]
                                    ]
                                  },
                                  {
                                    "Fn::Join": [
                                      "-",
                                      [
                                        "Comment",
                                        {
                                          "Ref": "GetAttGraphQLAPIApiId"
                                        }
                                      ]
                                    ]
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              }
            ]
          }
        },
        "CommentDataSource": {
          "Type": "AWS::AppSync::DataSource",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "Name": "CommentTable",
            "Type": "AMAZON_DYNAMODB",
            "ServiceRoleArn": {
              "Fn::GetAtt": [
                "CommentIAMRole",
                "Arn"
              ]
            },
            "DynamoDBConfig": {
              "AwsRegion": {
                "Ref": "AWS::Region"
              },
              "TableName": {
                "Fn::If": [
                  "HasEnvironmentParameter",
                  {
                    "Fn::Join": [
                      "-",
                      [
                        "Comment",
                        {
                          "Ref": "GetAttGraphQLAPIApiId"
                        },
                        {
                          "Ref": "env"
                        }
                      ]
                    ]
                  },
                  {
                    "Fn::Join": [
                      "-",
                      [
                        "Comment",
                        {
                          "Ref": "GetAttGraphQLAPIApiId"
                        }
                      ]
                    ]
                  }
                ]
              }
            }
          },
          "DependsOn": [
            "CommentIAMRole"
          ]
        },
        "GetCommentResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "CommentDataSource",
                "Name"
              ]
            },
            "FieldName": "getComment",
            "TypeName": "Query",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "getComment",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "getComment",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "ListCommentResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "CommentDataSource",
                "Name"
              ]
            },
            "FieldName": "listComments",
            "TypeName": "Query",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "listComments",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "listComments",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "CreateCommentResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "CommentDataSource",
                "Name"
              ]
            },
            "FieldName": "createComment",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "createComment",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "createComment",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "UpdateCommentResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "CommentDataSource",
                "Name"
              ]
            },
            "FieldName": "updateComment",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "updateComment",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "updateComment",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        },
        "DeleteCommentResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "GetAttGraphQLAPIApiId"
            },
            "DataSourceName": {
              "Fn::GetAtt": [
                "CommentDataSource",
                "Name"
              ]
            },
            "FieldName": "deleteComment",
            "TypeName": "Mutation",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "deleteComment",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "deleteComment",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          }
        }
      },
      "Outputs": {
        "GetAttCommentTableStreamArn": {
          "Description": "Your DynamoDB table StreamArn.",
          "Value": {
            "Fn::GetAtt": [
              "CommentTable",
              "StreamArn"
            ]
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "CommentTable",
                  "StreamArn"
                ]
              ]
            }
          }
        },
        "GetAttCommentDataSourceName": {
          "Description": "Your model DataSource name.",
          "Value": {
            "Fn::GetAtt": [
              "CommentDataSource",
              "Name"
            ]
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "CommentDataSource",
                  "Name"
                ]
              ]
            }
          }
        },
        "GetAttCommentTableName": {
          "Description": "Your DynamoDB table name.",
          "Value": {
            "Ref": "CommentTable"
          },
          "Export": {
            "Name": {
              "Fn::Join": [
                ":",
                [
                  {
                    "Ref": "AppSyncApiId"
                  },
                  "GetAtt",
                  "CommentTable",
                  "Name"
                ]
              ]
            }
          }
        }
      },
      "Mappings": {},
      "Conditions": {
        "ShouldUsePayPerRequestBilling": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBBillingMode"
            },
            "PAY_PER_REQUEST"
          ]
        },
        "ShouldUsePointInTimeRecovery": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBEnablePointInTimeRecovery"
            },
            "true"
          ]
        },
        "ShouldUseServerSideEncryption": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBEnableServerSideEncryption"
            },
            "true"
          ]
        },
        "HasEnvironmentParameter": {
          "Fn::Not": [
            {
              "Fn::Equals": [
                {
                  "Ref": "env"
                },
                "NONE"
              ]
            }
          ]
        }
      }
    },
    "FunctionDirectiveStack": {
      "AWSTemplateFormatVersion": "2010-09-09",
      "Description": "An auto-generated nested stack.",
      "Metadata": {},
      "Parameters": {
        "DynamoDBModelTableReadIOPS": {
          "Type": "Number",
          "Description": "The number of read IOPS the table should support.",
          "Default": 5
        },
        "DynamoDBModelTableWriteIOPS": {
          "Type": "Number",
          "Description": "The number of write IOPS the table should support.",
          "Default": 5
        },
        "DynamoDBBillingMode": {
          "Type": "String",
          "Description": "Configure @model types to create DynamoDB tables with PAY_PER_REQUEST or PROVISIONED billing modes.",
          "Default": "PAY_PER_REQUEST",
          "AllowedValues": [
            "PAY_PER_REQUEST",
            "PROVISIONED"
          ]
        },
        "DynamoDBEnablePointInTimeRecovery": {
          "Type": "String",
          "Description": "Whether to enable Point in Time Recovery on the table",
          "Default": "false",
          "AllowedValues": [
            "true",
            "false"
          ]
        },
        "DynamoDBEnableServerSideEncryption": {
          "Type": "String",
          "Description": "Enable server side encryption powered by KMS.",
          "Default": "true",
          "AllowedValues": [
            "true",
            "false"
          ]
        },
        "env": {
          "Type": "String",
          "Description": "The environment name. e.g. Dev, Test, or Production",
          "Default": "NONE"
        },
        "S3DeploymentBucket": {
          "Type": "String",
          "Description": "The S3 bucket containing all deployment assets for the project."
        },
        "S3DeploymentRootKey": {
          "Type": "String",
          "Description": "An S3 key relative to the S3DeploymentBucket that points to the root of the deployment directory."
        },
        "AppSyncApiId": {
          "Type": "String",
          "Description": "The id of the AppSync API associated with this project."
        },
        "GetAttGraphQLAPIApiId": {
          "Type": "String",
          "Description": "Auto-generated parameter that forwards Fn.GetAtt(GraphQLAPI, ApiId) through to nested stacks."
        }
      },
      "Resources": {
        "HelloWorldLambdaDataSourceRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "RoleName": {
              "Fn::If": [
                "HasEnvironmentParameter",
                {
                  "Fn::Join": [
                    "-",
                    [
                      "HelloWorlde9d6",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      },
                      {
                        "Ref": "env"
                      }
                    ]
                  ]
                },
                {
                  "Fn::Join": [
                    "-",
                    [
                      "HelloWorlde9d6",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      }
                    ]
                  ]
                }
              ]
            },
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "appsync.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "Policies": [
              {
                "PolicyName": "InvokeLambdaFunction",
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Action": [
                        "lambda:InvokeFunction"
                      ],
                      "Resource": {
                        "Fn::If": [
                          "HasEnvironmentParameter",
                          {
                            "Fn::Sub": [
                              "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${env}-hello-world",
                              {
                                "env": {
                                  "Ref": "env"
                                }
                              }
                            ]
                          },
                          {
                            "Fn::Sub": [
                              "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${env}-hello-world",
                              {}
                            ]
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "HelloWorldLambdaDataSource": {
          "Type": "AWS::AppSync::DataSource",
          "Properties": {
            "ApiId": {
              "Ref": "AppSyncApiId"
            },
            "Name": "HelloWorldLambdaDataSource",
            "Type": "AWS_LAMBDA",
            "ServiceRoleArn": {
              "Fn::GetAtt": [
                "HelloWorldLambdaDataSourceRole",
                "Arn"
              ]
            },
            "LambdaConfig": {
              "LambdaFunctionArn": {
                "Fn::If": [
                  "HasEnvironmentParameter",
                  {
                    "Fn::Sub": [
                      "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${env}-hello-world",
                      {
                        "env": {
                          "Ref": "env"
                        }
                      }
                    ]
                  },
                  {
                    "Fn::Sub": [
                      "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${env}-hello-world",
                      {}
                    ]
                  }
                ]
              }
            }
          },
          "DependsOn": "HelloWorldLambdaDataSourceRole"
        },
        "InvokeHelloWorldLambdaDataSource": {
          "Type": "AWS::AppSync::FunctionConfiguration",
          "Properties": {
            "ApiId": {
              "Ref": "AppSyncApiId"
            },
            "Name": "InvokeHelloWorldLambdaDataSource",
            "DataSourceName": "HelloWorldLambdaDataSource",
            "FunctionVersion": "2018-05-29",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/pipelineFunctions/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "InvokeHelloWorldLambdaDataSource",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/pipelineFunctions/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "InvokeHelloWorldLambdaDataSource",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          },
          "DependsOn": "HelloWorldLambdaDataSource"
        },
        "QueryhelloWorldResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "AppSyncApiId"
            },
            "TypeName": "Query",
            "FieldName": "helloWorld",
            "Kind": "PIPELINE",
            "PipelineConfig": {
              "Functions": [
                {
                  "Fn::GetAtt": [
                    "InvokeHelloWorldLambdaDataSource",
                    "FunctionId"
                  ]
                }
              ]
            },
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "helloWorld",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Query",
                        "helloWorld",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          },
          "DependsOn": "InvokeHelloWorldLambdaDataSource"
        },
        "GoodByeWorldLambdaDataSourceRole": {
          "Type": "AWS::IAM::Role",
          "Properties": {
            "RoleName": {
              "Fn::If": [
                "HasEnvironmentParameter",
                {
                  "Fn::Join": [
                    "-",
                    [
                      "GoodByeWorld56f2",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      },
                      {
                        "Ref": "env"
                      }
                    ]
                  ]
                },
                {
                  "Fn::Join": [
                    "-",
                    [
                      "GoodByeWorld56f2",
                      {
                        "Ref": "GetAttGraphQLAPIApiId"
                      }
                    ]
                  ]
                }
              ]
            },
            "AssumeRolePolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Principal": {
                    "Service": "appsync.amazonaws.com"
                  },
                  "Action": "sts:AssumeRole"
                }
              ]
            },
            "Policies": [
              {
                "PolicyName": "InvokeLambdaFunction",
                "PolicyDocument": {
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Action": [
                        "lambda:InvokeFunction"
                      ],
                      "Resource": {
                        "Fn::If": [
                          "HasEnvironmentParameter",
                          {
                            "Fn::Sub": [
                              "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${env}-good-bye-world",
                              {
                                "env": {
                                  "Ref": "env"
                                }
                              }
                            ]
                          },
                          {
                            "Fn::Sub": [
                              "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${env}-good-bye-world",
                              {}
                            ]
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          }
        },
        "GoodByeWorldLambdaDataSource": {
          "Type": "AWS::AppSync::DataSource",
          "Properties": {
            "ApiId": {
              "Ref": "AppSyncApiId"
            },
            "Name": "GoodByeWorldLambdaDataSource",
            "Type": "AWS_LAMBDA",
            "ServiceRoleArn": {
              "Fn::GetAtt": [
                "GoodByeWorldLambdaDataSourceRole",
                "Arn"
              ]
            },
            "LambdaConfig": {
              "LambdaFunctionArn": {
                "Fn::If": [
                  "HasEnvironmentParameter",
                  {
                    "Fn::Sub": [
                      "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${env}-good-bye-world",
                      {
                        "env": {
                          "Ref": "env"
                        }
                      }
                    ]
                  },
                  {
                    "Fn::Sub": [
                      "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${env}-good-bye-world",
                      {}
                    ]
                  }
                ]
              }
            }
          },
          "DependsOn": "GoodByeWorldLambdaDataSourceRole"
        },
        "InvokeGoodByeWorldLambdaDataSource": {
          "Type": "AWS::AppSync::FunctionConfiguration",
          "Properties": {
            "ApiId": {
              "Ref": "AppSyncApiId"
            },
            "Name": "InvokeGoodByeWorldLambdaDataSource",
            "DataSourceName": "GoodByeWorldLambdaDataSource",
            "FunctionVersion": "2018-05-29",
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/pipelineFunctions/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "InvokeGoodByeWorldLambdaDataSource",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/pipelineFunctions/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "InvokeGoodByeWorldLambdaDataSource",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          },
          "DependsOn": "GoodByeWorldLambdaDataSource"
        },
        "MutationgoodByeWorldResolver": {
          "Type": "AWS::AppSync::Resolver",
          "Properties": {
            "ApiId": {
              "Ref": "AppSyncApiId"
            },
            "TypeName": "Mutation",
            "FieldName": "goodByeWorld",
            "Kind": "PIPELINE",
            "PipelineConfig": {
              "Functions": [
                {
                  "Fn::GetAtt": [
                    "InvokeGoodByeWorldLambdaDataSource",
                    "FunctionId"
                  ]
                }
              ]
            },
            "RequestMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "goodByeWorld",
                        "req",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            },
            "ResponseMappingTemplateS3Location": {
              "Fn::Sub": [
                "s3://${S3DeploymentBucket}/${S3DeploymentRootKey}/resolvers/${ResolverFileName}",
                {
                  "S3DeploymentBucket": {
                    "Ref": "S3DeploymentBucket"
                  },
                  "S3DeploymentRootKey": {
                    "Ref": "S3DeploymentRootKey"
                  },
                  "ResolverFileName": {
                    "Fn::Join": [
                      ".",
                      [
                        "Mutation",
                        "goodByeWorld",
                        "res",
                        "vtl"
                      ]
                    ]
                  }
                }
              ]
            }
          },
          "DependsOn": "InvokeGoodByeWorldLambdaDataSource"
        }
      },
      "Outputs": {},
      "Mappings": {},
      "Conditions": {
        "ShouldUsePayPerRequestBilling": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBBillingMode"
            },
            "PAY_PER_REQUEST"
          ]
        },
        "ShouldUsePointInTimeRecovery": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBEnablePointInTimeRecovery"
            },
            "true"
          ]
        },
        "ShouldUseServerSideEncryption": {
          "Fn::Equals": [
            {
              "Ref": "DynamoDBEnableServerSideEncryption"
            },
            "true"
          ]
        },
        "HasEnvironmentParameter": {
          "Fn::Not": [
            {
              "Fn::Equals": [
                {
                  "Ref": "env"
                },
                "NONE"
              ]
            }
          ]
        }
      }
    }
  },
  "stackMapping": {
    "GraphQLAPI": "root",
    "BlogTable": "Blog",
    "BlogIAMRole": "Blog",
    "BlogDataSource": "Blog",
    "GetBlogResolver": "Blog",
    "ListBlogResolver": "Blog",
    "CreateBlogResolver": "Blog",
    "UpdateBlogResolver": "Blog",
    "DeleteBlogResolver": "Blog",
    "BlogPostTable": "BlogPost",
    "BlogPostIAMRole": "BlogPost",
    "BlogPostDataSource": "BlogPost",
    "GetBlogPostResolver": "BlogPost",
    "ListBlogPostResolver": "BlogPost",
    "CreateBlogPostResolver": "BlogPost",
    "UpdateBlogPostResolver": "BlogPost",
    "DeleteBlogPostResolver": "BlogPost",
    "CommentTable": "Comment",
    "CommentIAMRole": "Comment",
    "CommentDataSource": "Comment",
    "GetCommentResolver": "Comment",
    "ListCommentResolver": "Comment",
    "CreateCommentResolver": "Comment",
    "UpdateCommentResolver": "Comment",
    "DeleteCommentResolver": "Comment",
    "HelloWorldLambdaDataSourceRole": "FunctionDirectiveStack",
    "HelloWorldLambdaDataSource": "FunctionDirectiveStack",
    "InvokeHelloWorldLambdaDataSource": "FunctionDirectiveStack",
    "QueryhelloWorldResolver": "FunctionDirectiveStack",
    "GoodByeWorldLambdaDataSourceRole": "FunctionDirectiveStack",
    "GoodByeWorldLambdaDataSource": "FunctionDirectiveStack",
    "InvokeGoodByeWorldLambdaDataSource": "FunctionDirectiveStack",
    "MutationgoodByeWorldResolver": "FunctionDirectiveStack",
    "GraphQLSchema": "root",
    "GraphQLAPIIdOutput": "root",
    "GraphQLAPIEndpointOutput": "root",
    "GetAttBlogTableStreamArn": "Blog",
    "GetAttBlogDataSourceName": "Blog",
    "GetAttBlogTableName": "Blog",
    "GetAttBlogPostTableStreamArn": "BlogPost",
    "GetAttBlogPostDataSourceName": "BlogPost",
    "GetAttBlogPostTableName": "BlogPost",
    "GetAttCommentTableStreamArn": "Comment",
    "GetAttCommentDataSourceName": "Comment",
    "GetAttCommentTableName": "Comment"
  },
  "resolvers": {
    "Query.getBlog.req.vtl": "## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogId\": $util.dynamodb.toDynamoDB($ctx.args.blogId)\n} )\n## [End] Set the primary @key. **\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"GetItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": $util.dynamodb.toDynamoDBJson($ctx.args.id)\n} #end\n}",
    "Query.getBlog.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Query.listBlogs.req.vtl": "## [Start] Set query expression for @key **\n#if( !$util.isNull($ctx.args.sortDirection) )\n  $util.error(\"sortDirection is not supported for List operations without a Sort key defined.\", \"InvalidArgumentsError\")\n#end\n#set( $modelQueryExpression = {} )\n#if( !$util.isNull($ctx.args.blogId) )\n  #set( $modelQueryExpression.expression = \"#blogId = :blogId\" )\n  #set( $modelQueryExpression.expressionNames = {\n  \"#blogId\": \"blogId\"\n} )\n  #set( $modelQueryExpression.expressionValues = {\n  \":blogId\": {\n      \"S\": \"$ctx.args.blogId\"\n  }\n} )\n#end\n## [End] Set query expression for @key **\n#set( $limit = $util.defaultIfNull($context.args.limit, 100) )\n#set( $ListRequest = {\n  \"version\": \"2018-05-29\",\n  \"limit\": $limit\n} )\n#if( $context.args.nextToken )\n  #set( $ListRequest.nextToken = $context.args.nextToken )\n#end\n#if( $context.args.filter )\n  #set( $ListRequest.filter = $util.parseJson(\"$util.transform.toDynamoDBFilterExpression($ctx.args.filter)\") )\n#end\n#if( !$util.isNull($modelQueryExpression)\n                        && !$util.isNullOrEmpty($modelQueryExpression.expression) )\n  $util.qr($ListRequest.put(\"operation\", \"Query\"))\n  $util.qr($ListRequest.put(\"query\", $modelQueryExpression))\n  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \"DESC\" )\n    #set( $ListRequest.scanIndexForward = false )\n  #else\n    #set( $ListRequest.scanIndexForward = true )\n  #end\n#else\n  $util.qr($ListRequest.put(\"operation\", \"Scan\"))\n#end\n$util.toJson($ListRequest)",
    "Query.listBlogs.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.createBlog.req.vtl": "## [Start] Set default values. **\n#set( $createdAt = $util.time.nowISO8601() )\n## Automatically set the createdAt timestamp. **\n$util.qr($context.args.input.put(\"createdAt\", $util.defaultIfNull($ctx.args.input.createdAt, $createdAt)))\n## Automatically set the updatedAt timestamp. **\n$util.qr($context.args.input.put(\"updatedAt\", $util.defaultIfNull($ctx.args.input.updatedAt, $createdAt)))\n## [End] Set default values. **\n## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogId)\n} )\n## [End] Set the primary @key. **\n\n## [Start] Prepare DynamoDB PutItem Request. **\n$util.qr($context.args.input.put(\"__typename\", \"Blog\"))\n#set( $condition = {\n  \"expression\": \"attribute_not_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  }\n} )\n#if( $context.args.condition )\n  #set( $condition.expressionValues = {} )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"PutItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\":   $util.dynamodb.toDynamoDBJson($ctx.args.input.id)\n} #end,\n  \"attributeValues\": $util.dynamodb.toMapValuesJson($context.args.input),\n  \"condition\": $util.toJson($condition)\n}\n## [End] Prepare DynamoDB PutItem Request. **",
    "Mutation.createBlog.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.updateBlog.req.vtl": "## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogId)\n} )\n## [End] Set the primary @key. **\n\n#if( $authCondition && $authCondition.expression != \"\" )\n  #set( $condition = $authCondition )\n  #if( $modelObjectKey )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#id)\"))\n    $util.qr($condition.expressionNames.put(\"#id\", \"id\"))\n  #end\n#else\n  #if( $modelObjectKey )\n    #set( $condition = {\n  \"expression\": \"\",\n  \"expressionNames\": {},\n  \"expressionValues\": {}\n} )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      #if( $velocityCount == 1 )\n        $util.qr($condition.put(\"expression\", \"attribute_exists(#keyCondition$velocityCount)\"))\n      #else\n        $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      #end\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    #set( $condition = {\n  \"expression\": \"attribute_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  },\n  \"expressionValues\": {}\n} )\n  #end\n#end\n## Automatically set the updatedAt timestamp. **\n$util.qr($context.args.input.put(\"updatedAt\", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))\n$util.qr($context.args.input.put(\"__typename\", \"Blog\"))\n## Update condition if type is @versioned **\n#if( $versionedCondition )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $versionedCondition.expression\"))\n  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))\n  $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))\n#end\n#if( $context.args.condition )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n#set( $expNames = {} )\n#set( $expValues = {} )\n#set( $expSet = {} )\n#set( $expAdd = {} )\n#set( $expRemove = [] )\n#if( $modelObjectKey )\n  #set( $keyFields = [] )\n  #foreach( $entry in $modelObjectKey.entrySet() )\n    $util.qr($keyFields.add(\"$entry.key\"))\n  #end\n#else\n  #set( $keyFields = [\"id\"] )\n#end\n#foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )\n  #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey(\"$entry.key\") )\n    #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get(\"$entry.key\") )\n  #else\n    #set( $entryKeyAttributeName = $entry.key )\n  #end\n  #if( $util.isNull($entry.value) )\n    #set( $discard = $expRemove.add(\"#$entryKeyAttributeName\") )\n    $util.qr($expNames.put(\"#$entryKeyAttributeName\", \"$entry.key\"))\n  #else\n    $util.qr($expSet.put(\"#$entryKeyAttributeName\", \":$entryKeyAttributeName\"))\n    $util.qr($expNames.put(\"#$entryKeyAttributeName\", \"$entry.key\"))\n    $util.qr($expValues.put(\":$entryKeyAttributeName\", $util.dynamodb.toDynamoDB($entry.value)))\n  #end\n#end\n#set( $expression = \"\" )\n#if( !$expSet.isEmpty() )\n  #set( $expression = \"SET\" )\n  #foreach( $entry in $expSet.entrySet() )\n    #set( $expression = \"$expression $entry.key = $entry.value\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#if( !$expAdd.isEmpty() )\n  #set( $expression = \"$expression ADD\" )\n  #foreach( $entry in $expAdd.entrySet() )\n    #set( $expression = \"$expression $entry.key $entry.value\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#if( !$expRemove.isEmpty() )\n  #set( $expression = \"$expression REMOVE\" )\n  #foreach( $entry in $expRemove )\n    #set( $expression = \"$expression $entry\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#set( $update = {} )\n$util.qr($update.put(\"expression\", \"$expression\"))\n#if( !$expNames.isEmpty() )\n  $util.qr($update.put(\"expressionNames\", $expNames))\n#end\n#if( !$expValues.isEmpty() )\n  $util.qr($update.put(\"expressionValues\", $expValues))\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"UpdateItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": {\n      \"S\": $util.toJson($context.args.input.id)\n  }\n} #end,\n  \"update\": $util.toJson($update),\n  \"condition\": $util.toJson($condition)\n}",
    "Mutation.updateBlog.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.deleteBlog.req.vtl": "## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogId)\n} )\n## [End] Set the primary @key. **\n#if( $authCondition )\n  #set( $condition = $authCondition )\n  #if( $modelObjectKey )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#id)\"))\n    $util.qr($condition.expressionNames.put(\"#id\", \"id\"))\n  #end\n#else\n  #if( $modelObjectKey )\n    #set( $condition = {\n  \"expression\": \"\",\n  \"expressionNames\": {}\n} )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      #if( $velocityCount == 1 )\n        $util.qr($condition.put(\"expression\", \"attribute_exists(#keyCondition$velocityCount)\"))\n      #else\n        $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      #end\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    #set( $condition = {\n  \"expression\": \"attribute_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  }\n} )\n  #end\n#end\n#if( $versionedCondition )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $versionedCondition.expression\"))\n  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))\n  #set( $expressionValues = $util.defaultIfNull($condition.expressionValues, {}) )\n  $util.qr($expressionValues.putAll($versionedCondition.expressionValues))\n  #set( $condition.expressionValues = $expressionValues )\n#end\n#if( $context.args.condition )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  #set( $conditionExpressionValues = $util.defaultIfNull($condition.expressionValues, {}) )\n  $util.qr($conditionExpressionValues.putAll($conditionFilterExpressions.expressionValues))\n  #set( $condition.expressionValues = $conditionExpressionValues )\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"DeleteItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)\n} #end,\n  \"condition\": $util.toJson($condition)\n}",
    "Mutation.deleteBlog.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Query.getBlogPost.req.vtl": "## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogId\": $util.dynamodb.toDynamoDB($ctx.args.blogId),\n  \"blogPostId\": $util.dynamodb.toDynamoDB($ctx.args.blogPostId)\n} )\n## [End] Set the primary @key. **\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"GetItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": $util.dynamodb.toDynamoDBJson($ctx.args.id)\n} #end\n}",
    "Query.getBlogPost.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Query.listBlogPosts.req.vtl": "## [Start] Set query expression for @key **\n#if( $util.isNull($ctx.args.blogId) && !$util.isNull($ctx.args.sortDirection) )\n  $util.error(\"When providing argument 'sortDirection' you must also provide argument 'blogId'.\", \"InvalidArgumentsError\")\n#end\n#set( $modelQueryExpression = {} )\n## [Start] Validate key arguments. **\n#if( !$util.isNull($ctx.args.blogPostId) && $util.isNull($ctx.args.blogId) )\n  $util.error(\"When providing argument 'blogPostId' you must also provide arguments blogId\", \"InvalidArgumentsError\")\n#end\n## [End] Validate key arguments. **\n#if( !$util.isNull($ctx.args.blogId) )\n  #set( $modelQueryExpression.expression = \"#blogId = :blogId\" )\n  #set( $modelQueryExpression.expressionNames = {\n  \"#blogId\": \"blogId\"\n} )\n  #set( $modelQueryExpression.expressionValues = {\n  \":blogId\": {\n      \"S\": \"$ctx.args.blogId\"\n  }\n} )\n#end\n## [Start] Applying Key Condition **\n#if( !$util.isNull($ctx.args.blogPostId) && !$util.isNull($ctx.args.blogPostId.beginsWith) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"blogPostId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.blogPostId.beginsWith\" }))\n#end\n#if( !$util.isNull($ctx.args.blogPostId) && !$util.isNull($ctx.args.blogPostId.between) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"blogPostId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey0\", { \"S\": \"$ctx.args.blogPostId.between[0]\" }))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey1\", { \"S\": \"$ctx.args.blogPostId.between[1]\" }))\n#end\n#if( !$util.isNull($ctx.args.blogPostId) && !$util.isNull($ctx.args.blogPostId.eq) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey = :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"blogPostId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.blogPostId.eq\" }))\n#end\n#if( !$util.isNull($ctx.args.blogPostId) && !$util.isNull($ctx.args.blogPostId.lt) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey < :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"blogPostId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.blogPostId.lt\" }))\n#end\n#if( !$util.isNull($ctx.args.blogPostId) && !$util.isNull($ctx.args.blogPostId.le) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey <= :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"blogPostId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.blogPostId.le\" }))\n#end\n#if( !$util.isNull($ctx.args.blogPostId) && !$util.isNull($ctx.args.blogPostId.gt) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey > :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"blogPostId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.blogPostId.gt\" }))\n#end\n#if( !$util.isNull($ctx.args.blogPostId) && !$util.isNull($ctx.args.blogPostId.ge) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey >= :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"blogPostId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.blogPostId.ge\" }))\n#end\n## [End] Applying Key Condition **\n## [End] Set query expression for @key **\n#set( $limit = $util.defaultIfNull($context.args.limit, 100) )\n#set( $ListRequest = {\n  \"version\": \"2018-05-29\",\n  \"limit\": $limit\n} )\n#if( $context.args.nextToken )\n  #set( $ListRequest.nextToken = $context.args.nextToken )\n#end\n#if( $context.args.filter )\n  #set( $ListRequest.filter = $util.parseJson(\"$util.transform.toDynamoDBFilterExpression($ctx.args.filter)\") )\n#end\n#if( !$util.isNull($modelQueryExpression)\n                        && !$util.isNullOrEmpty($modelQueryExpression.expression) )\n  $util.qr($ListRequest.put(\"operation\", \"Query\"))\n  $util.qr($ListRequest.put(\"query\", $modelQueryExpression))\n  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \"DESC\" )\n    #set( $ListRequest.scanIndexForward = false )\n  #else\n    #set( $ListRequest.scanIndexForward = true )\n  #end\n#else\n  $util.qr($ListRequest.put(\"operation\", \"Scan\"))\n#end\n$util.toJson($ListRequest)",
    "Query.listBlogPosts.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.createBlogPost.req.vtl": "## [Start] Set default values. **\n#set( $createdAt = $util.time.nowISO8601() )\n## Automatically set the createdAt timestamp. **\n$util.qr($context.args.input.put(\"createdAt\", $util.defaultIfNull($ctx.args.input.createdAt, $createdAt)))\n## Automatically set the updatedAt timestamp. **\n$util.qr($context.args.input.put(\"updatedAt\", $util.defaultIfNull($ctx.args.input.updatedAt, $createdAt)))\n## [End] Set default values. **\n## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogId),\n  \"blogPostId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogPostId)\n} )\n## [End] Set the primary @key. **\n\n## [Start] Prepare DynamoDB PutItem Request. **\n$util.qr($context.args.input.put(\"__typename\", \"BlogPost\"))\n#set( $condition = {\n  \"expression\": \"attribute_not_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  }\n} )\n#if( $context.args.condition )\n  #set( $condition.expressionValues = {} )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"PutItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\":   $util.dynamodb.toDynamoDBJson($ctx.args.input.id)\n} #end,\n  \"attributeValues\": $util.dynamodb.toMapValuesJson($context.args.input),\n  \"condition\": $util.toJson($condition)\n}\n## [End] Prepare DynamoDB PutItem Request. **",
    "Mutation.createBlogPost.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.updateBlogPost.req.vtl": "## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogId),\n  \"blogPostId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogPostId)\n} )\n## [End] Set the primary @key. **\n\n#if( $authCondition && $authCondition.expression != \"\" )\n  #set( $condition = $authCondition )\n  #if( $modelObjectKey )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#id)\"))\n    $util.qr($condition.expressionNames.put(\"#id\", \"id\"))\n  #end\n#else\n  #if( $modelObjectKey )\n    #set( $condition = {\n  \"expression\": \"\",\n  \"expressionNames\": {},\n  \"expressionValues\": {}\n} )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      #if( $velocityCount == 1 )\n        $util.qr($condition.put(\"expression\", \"attribute_exists(#keyCondition$velocityCount)\"))\n      #else\n        $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      #end\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    #set( $condition = {\n  \"expression\": \"attribute_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  },\n  \"expressionValues\": {}\n} )\n  #end\n#end\n## Automatically set the updatedAt timestamp. **\n$util.qr($context.args.input.put(\"updatedAt\", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))\n$util.qr($context.args.input.put(\"__typename\", \"BlogPost\"))\n## Update condition if type is @versioned **\n#if( $versionedCondition )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $versionedCondition.expression\"))\n  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))\n  $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))\n#end\n#if( $context.args.condition )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n#set( $expNames = {} )\n#set( $expValues = {} )\n#set( $expSet = {} )\n#set( $expAdd = {} )\n#set( $expRemove = [] )\n#if( $modelObjectKey )\n  #set( $keyFields = [] )\n  #foreach( $entry in $modelObjectKey.entrySet() )\n    $util.qr($keyFields.add(\"$entry.key\"))\n  #end\n#else\n  #set( $keyFields = [\"id\"] )\n#end\n#foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )\n  #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey(\"$entry.key\") )\n    #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get(\"$entry.key\") )\n  #else\n    #set( $entryKeyAttributeName = $entry.key )\n  #end\n  #if( $util.isNull($entry.value) )\n    #set( $discard = $expRemove.add(\"#$entryKeyAttributeName\") )\n    $util.qr($expNames.put(\"#$entryKeyAttributeName\", \"$entry.key\"))\n  #else\n    $util.qr($expSet.put(\"#$entryKeyAttributeName\", \":$entryKeyAttributeName\"))\n    $util.qr($expNames.put(\"#$entryKeyAttributeName\", \"$entry.key\"))\n    $util.qr($expValues.put(\":$entryKeyAttributeName\", $util.dynamodb.toDynamoDB($entry.value)))\n  #end\n#end\n#set( $expression = \"\" )\n#if( !$expSet.isEmpty() )\n  #set( $expression = \"SET\" )\n  #foreach( $entry in $expSet.entrySet() )\n    #set( $expression = \"$expression $entry.key = $entry.value\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#if( !$expAdd.isEmpty() )\n  #set( $expression = \"$expression ADD\" )\n  #foreach( $entry in $expAdd.entrySet() )\n    #set( $expression = \"$expression $entry.key $entry.value\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#if( !$expRemove.isEmpty() )\n  #set( $expression = \"$expression REMOVE\" )\n  #foreach( $entry in $expRemove )\n    #set( $expression = \"$expression $entry\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#set( $update = {} )\n$util.qr($update.put(\"expression\", \"$expression\"))\n#if( !$expNames.isEmpty() )\n  $util.qr($update.put(\"expressionNames\", $expNames))\n#end\n#if( !$expValues.isEmpty() )\n  $util.qr($update.put(\"expressionValues\", $expValues))\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"UpdateItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": {\n      \"S\": $util.toJson($context.args.input.id)\n  }\n} #end,\n  \"update\": $util.toJson($update),\n  \"condition\": $util.toJson($condition)\n}",
    "Mutation.updateBlogPost.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.deleteBlogPost.req.vtl": "## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogId),\n  \"blogPostId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogPostId)\n} )\n## [End] Set the primary @key. **\n#if( $authCondition )\n  #set( $condition = $authCondition )\n  #if( $modelObjectKey )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#id)\"))\n    $util.qr($condition.expressionNames.put(\"#id\", \"id\"))\n  #end\n#else\n  #if( $modelObjectKey )\n    #set( $condition = {\n  \"expression\": \"\",\n  \"expressionNames\": {}\n} )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      #if( $velocityCount == 1 )\n        $util.qr($condition.put(\"expression\", \"attribute_exists(#keyCondition$velocityCount)\"))\n      #else\n        $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      #end\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    #set( $condition = {\n  \"expression\": \"attribute_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  }\n} )\n  #end\n#end\n#if( $versionedCondition )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $versionedCondition.expression\"))\n  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))\n  #set( $expressionValues = $util.defaultIfNull($condition.expressionValues, {}) )\n  $util.qr($expressionValues.putAll($versionedCondition.expressionValues))\n  #set( $condition.expressionValues = $expressionValues )\n#end\n#if( $context.args.condition )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  #set( $conditionExpressionValues = $util.defaultIfNull($condition.expressionValues, {}) )\n  $util.qr($conditionExpressionValues.putAll($conditionFilterExpressions.expressionValues))\n  #set( $condition.expressionValues = $conditionExpressionValues )\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"DeleteItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)\n} #end,\n  \"condition\": $util.toJson($condition)\n}",
    "Mutation.deleteBlogPost.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Query.getComment.req.vtl": "## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogPostId\": $util.dynamodb.toDynamoDB($ctx.args.blogPostId),\n  \"commentId\": $util.dynamodb.toDynamoDB($ctx.args.commentId)\n} )\n## [End] Set the primary @key. **\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"GetItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": $util.dynamodb.toDynamoDBJson($ctx.args.id)\n} #end\n}",
    "Query.getComment.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Query.listComments.req.vtl": "## [Start] Set query expression for @key **\n#if( $util.isNull($ctx.args.blogPostId) && !$util.isNull($ctx.args.sortDirection) )\n  $util.error(\"When providing argument 'sortDirection' you must also provide argument 'blogPostId'.\", \"InvalidArgumentsError\")\n#end\n#set( $modelQueryExpression = {} )\n## [Start] Validate key arguments. **\n#if( !$util.isNull($ctx.args.commentId) && $util.isNull($ctx.args.blogPostId) )\n  $util.error(\"When providing argument 'commentId' you must also provide arguments blogPostId\", \"InvalidArgumentsError\")\n#end\n## [End] Validate key arguments. **\n#if( !$util.isNull($ctx.args.blogPostId) )\n  #set( $modelQueryExpression.expression = \"#blogPostId = :blogPostId\" )\n  #set( $modelQueryExpression.expressionNames = {\n  \"#blogPostId\": \"blogPostId\"\n} )\n  #set( $modelQueryExpression.expressionValues = {\n  \":blogPostId\": {\n      \"S\": \"$ctx.args.blogPostId\"\n  }\n} )\n#end\n## [Start] Applying Key Condition **\n#if( !$util.isNull($ctx.args.commentId) && !$util.isNull($ctx.args.commentId.beginsWith) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND begins_with(#sortKey, :sortKey)\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"commentId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.commentId.beginsWith\" }))\n#end\n#if( !$util.isNull($ctx.args.commentId) && !$util.isNull($ctx.args.commentId.between) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"commentId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey0\", { \"S\": \"$ctx.args.commentId.between[0]\" }))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey1\", { \"S\": \"$ctx.args.commentId.between[1]\" }))\n#end\n#if( !$util.isNull($ctx.args.commentId) && !$util.isNull($ctx.args.commentId.eq) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey = :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"commentId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.commentId.eq\" }))\n#end\n#if( !$util.isNull($ctx.args.commentId) && !$util.isNull($ctx.args.commentId.lt) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey < :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"commentId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.commentId.lt\" }))\n#end\n#if( !$util.isNull($ctx.args.commentId) && !$util.isNull($ctx.args.commentId.le) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey <= :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"commentId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.commentId.le\" }))\n#end\n#if( !$util.isNull($ctx.args.commentId) && !$util.isNull($ctx.args.commentId.gt) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey > :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"commentId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.commentId.gt\" }))\n#end\n#if( !$util.isNull($ctx.args.commentId) && !$util.isNull($ctx.args.commentId.ge) )\n  #set( $modelQueryExpression.expression = \"$modelQueryExpression.expression AND #sortKey >= :sortKey\" )\n  $util.qr($modelQueryExpression.expressionNames.put(\"#sortKey\", \"commentId\"))\n  $util.qr($modelQueryExpression.expressionValues.put(\":sortKey\", { \"S\": \"$ctx.args.commentId.ge\" }))\n#end\n## [End] Applying Key Condition **\n## [End] Set query expression for @key **\n#set( $limit = $util.defaultIfNull($context.args.limit, 100) )\n#set( $ListRequest = {\n  \"version\": \"2018-05-29\",\n  \"limit\": $limit\n} )\n#if( $context.args.nextToken )\n  #set( $ListRequest.nextToken = $context.args.nextToken )\n#end\n#if( $context.args.filter )\n  #set( $ListRequest.filter = $util.parseJson(\"$util.transform.toDynamoDBFilterExpression($ctx.args.filter)\") )\n#end\n#if( !$util.isNull($modelQueryExpression)\n                        && !$util.isNullOrEmpty($modelQueryExpression.expression) )\n  $util.qr($ListRequest.put(\"operation\", \"Query\"))\n  $util.qr($ListRequest.put(\"query\", $modelQueryExpression))\n  #if( !$util.isNull($ctx.args.sortDirection) && $ctx.args.sortDirection == \"DESC\" )\n    #set( $ListRequest.scanIndexForward = false )\n  #else\n    #set( $ListRequest.scanIndexForward = true )\n  #end\n#else\n  $util.qr($ListRequest.put(\"operation\", \"Scan\"))\n#end\n$util.toJson($ListRequest)",
    "Query.listComments.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.createComment.req.vtl": "## [Start] Set default values. **\n#set( $createdAt = $util.time.nowISO8601() )\n## Automatically set the createdAt timestamp. **\n$util.qr($context.args.input.put(\"createdAt\", $util.defaultIfNull($ctx.args.input.createdAt, $createdAt)))\n## Automatically set the updatedAt timestamp. **\n$util.qr($context.args.input.put(\"updatedAt\", $util.defaultIfNull($ctx.args.input.updatedAt, $createdAt)))\n## [End] Set default values. **\n\n\n## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogPostId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogPostId),\n  \"commentId\": $util.dynamodb.toDynamoDB($ctx.args.input.commentId)\n} )\n## [End] Set the primary @key. **\n\n## [Start] Prepare DynamoDB PutItem Request. **\n$util.qr($context.args.input.put(\"__typename\", \"Comment\"))\n#set( $condition = {\n  \"expression\": \"attribute_not_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  }\n} )\n#if( $context.args.condition )\n  #set( $condition.expressionValues = {} )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"PutItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\":   $util.dynamodb.toDynamoDBJson($ctx.args.input.id)\n} #end,\n  \"attributeValues\": $util.dynamodb.toMapValuesJson($context.args.input),\n  \"condition\": $util.toJson($condition)\n}\n## [End] Prepare DynamoDB PutItem Request. **",
    "Mutation.createComment.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.updateComment.req.vtl": "\n\n## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogPostId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogPostId),\n  \"commentId\": $util.dynamodb.toDynamoDB($ctx.args.input.commentId)\n} )\n## [End] Set the primary @key. **\n\n#if( $authCondition && $authCondition.expression != \"\" )\n  #set( $condition = $authCondition )\n  #if( $modelObjectKey )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#id)\"))\n    $util.qr($condition.expressionNames.put(\"#id\", \"id\"))\n  #end\n#else\n  #if( $modelObjectKey )\n    #set( $condition = {\n  \"expression\": \"\",\n  \"expressionNames\": {},\n  \"expressionValues\": {}\n} )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      #if( $velocityCount == 1 )\n        $util.qr($condition.put(\"expression\", \"attribute_exists(#keyCondition$velocityCount)\"))\n      #else\n        $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      #end\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    #set( $condition = {\n  \"expression\": \"attribute_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  },\n  \"expressionValues\": {}\n} )\n  #end\n#end\n## Automatically set the updatedAt timestamp. **\n$util.qr($context.args.input.put(\"updatedAt\", $util.defaultIfNull($ctx.args.input.updatedAt, $util.time.nowISO8601())))\n$util.qr($context.args.input.put(\"__typename\", \"Comment\"))\n## Update condition if type is @versioned **\n#if( $versionedCondition )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $versionedCondition.expression\"))\n  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))\n  $util.qr($condition.expressionValues.putAll($versionedCondition.expressionValues))\n#end\n#if( $context.args.condition )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n#set( $expNames = {} )\n#set( $expValues = {} )\n#set( $expSet = {} )\n#set( $expAdd = {} )\n#set( $expRemove = [] )\n#if( $modelObjectKey )\n  #set( $keyFields = [] )\n  #foreach( $entry in $modelObjectKey.entrySet() )\n    $util.qr($keyFields.add(\"$entry.key\"))\n  #end\n#else\n  #set( $keyFields = [\"id\"] )\n#end\n#foreach( $entry in $util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet() )\n  #if( !$util.isNull($dynamodbNameOverrideMap) && $dynamodbNameOverrideMap.containsKey(\"$entry.key\") )\n    #set( $entryKeyAttributeName = $dynamodbNameOverrideMap.get(\"$entry.key\") )\n  #else\n    #set( $entryKeyAttributeName = $entry.key )\n  #end\n  #if( $util.isNull($entry.value) )\n    #set( $discard = $expRemove.add(\"#$entryKeyAttributeName\") )\n    $util.qr($expNames.put(\"#$entryKeyAttributeName\", \"$entry.key\"))\n  #else\n    $util.qr($expSet.put(\"#$entryKeyAttributeName\", \":$entryKeyAttributeName\"))\n    $util.qr($expNames.put(\"#$entryKeyAttributeName\", \"$entry.key\"))\n    $util.qr($expValues.put(\":$entryKeyAttributeName\", $util.dynamodb.toDynamoDB($entry.value)))\n  #end\n#end\n#set( $expression = \"\" )\n#if( !$expSet.isEmpty() )\n  #set( $expression = \"SET\" )\n  #foreach( $entry in $expSet.entrySet() )\n    #set( $expression = \"$expression $entry.key = $entry.value\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#if( !$expAdd.isEmpty() )\n  #set( $expression = \"$expression ADD\" )\n  #foreach( $entry in $expAdd.entrySet() )\n    #set( $expression = \"$expression $entry.key $entry.value\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#if( !$expRemove.isEmpty() )\n  #set( $expression = \"$expression REMOVE\" )\n  #foreach( $entry in $expRemove )\n    #set( $expression = \"$expression $entry\" )\n    #if( $foreach.hasNext() )\n      #set( $expression = \"$expression,\" )\n    #end\n  #end\n#end\n#set( $update = {} )\n$util.qr($update.put(\"expression\", \"$expression\"))\n#if( !$expNames.isEmpty() )\n  $util.qr($update.put(\"expressionNames\", $expNames))\n#end\n#if( !$expValues.isEmpty() )\n  $util.qr($update.put(\"expressionValues\", $expValues))\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"UpdateItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": {\n      \"S\": $util.toJson($context.args.input.id)\n  }\n} #end,\n  \"update\": $util.toJson($update),\n  \"condition\": $util.toJson($condition)\n}",
    "Mutation.updateComment.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Mutation.deleteComment.req.vtl": "\n## [Start] Set the primary @key. **\n#set( $modelObjectKey = {\n  \"blogPostId\": $util.dynamodb.toDynamoDB($ctx.args.input.blogPostId),\n  \"commentId\": $util.dynamodb.toDynamoDB($ctx.args.input.commentId)\n} )\n## [End] Set the primary @key. **\n#if( $authCondition )\n  #set( $condition = $authCondition )\n  #if( $modelObjectKey )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#id)\"))\n    $util.qr($condition.expressionNames.put(\"#id\", \"id\"))\n  #end\n#else\n  #if( $modelObjectKey )\n    #set( $condition = {\n  \"expression\": \"\",\n  \"expressionNames\": {}\n} )\n    #foreach( $entry in $modelObjectKey.entrySet() )\n      #if( $velocityCount == 1 )\n        $util.qr($condition.put(\"expression\", \"attribute_exists(#keyCondition$velocityCount)\"))\n      #else\n        $util.qr($condition.put(\"expression\", \"$condition.expression AND attribute_exists(#keyCondition$velocityCount)\"))\n      #end\n      $util.qr($condition.expressionNames.put(\"#keyCondition$velocityCount\", \"$entry.key\"))\n    #end\n  #else\n    #set( $condition = {\n  \"expression\": \"attribute_exists(#id)\",\n  \"expressionNames\": {\n      \"#id\": \"id\"\n  }\n} )\n  #end\n#end\n#if( $versionedCondition )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $versionedCondition.expression\"))\n  $util.qr($condition.expressionNames.putAll($versionedCondition.expressionNames))\n  #set( $expressionValues = $util.defaultIfNull($condition.expressionValues, {}) )\n  $util.qr($expressionValues.putAll($versionedCondition.expressionValues))\n  #set( $condition.expressionValues = $expressionValues )\n#end\n#if( $context.args.condition )\n  #set( $conditionFilterExpressions = $util.parseJson($util.transform.toDynamoDBConditionExpression($context.args.condition)) )\n  $util.qr($condition.put(\"expression\", \"($condition.expression) AND $conditionFilterExpressions.expression\"))\n  $util.qr($condition.expressionNames.putAll($conditionFilterExpressions.expressionNames))\n  #set( $conditionExpressionValues = $util.defaultIfNull($condition.expressionValues, {}) )\n  $util.qr($conditionExpressionValues.putAll($conditionFilterExpressions.expressionValues))\n  #set( $condition.expressionValues = $conditionExpressionValues )\n  $util.qr($condition.expressionValues.putAll($conditionFilterExpressions.expressionValues))\n#end\n#if( $condition.expressionValues && $condition.expressionValues.size() == 0 )\n  #set( $condition = {\n  \"expression\": $condition.expression,\n  \"expressionNames\": $condition.expressionNames\n} )\n#end\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"DeleteItem\",\n  \"key\": #if( $modelObjectKey ) $util.toJson($modelObjectKey) #else {\n  \"id\": $util.dynamodb.toDynamoDBJson($ctx.args.input.id)\n} #end,\n  \"condition\": $util.toJson($condition)\n}",
    "Mutation.deleteComment.res.vtl": "#if( $ctx.error )\n$util.error($ctx.error.message, $ctx.error.type)\n#else\n$util.toJson($ctx.result)\n#end",
    "Query.helloWorld.req.vtl": "## [Start] Stash resolver specific context.. **\n$util.qr($ctx.stash.put(\"typeName\", \"Query\"))\n$util.qr($ctx.stash.put(\"fieldName\", \"helloWorld\"))\n{}\n## [End] Stash resolver specific context.. **",
    "Query.helloWorld.res.vtl": "$util.toJson($ctx.prev.result)",
    "Mutation.goodByeWorld.req.vtl": "## [Start] Stash resolver specific context.. **\n$util.qr($ctx.stash.put(\"typeName\", \"Mutation\"))\n$util.qr($ctx.stash.put(\"fieldName\", \"goodByeWorld\"))\n{}\n## [End] Stash resolver specific context.. **",
    "Mutation.goodByeWorld.res.vtl": "$util.toJson($ctx.prev.result)"
  },
  "functions": {},
  "pipelineFunctions": {
    "InvokeHelloWorldLambdaDataSource.req.vtl": "## [Start] Invoke AWS Lambda data source: HelloWorldLambdaDataSource. **\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"Invoke\",\n  \"payload\": {\n      \"typeName\": \"$ctx.stash.get(\"typeName\")\",\n      \"fieldName\": \"$ctx.stash.get(\"fieldName\")\",\n      \"arguments\": $util.toJson($ctx.arguments),\n      \"identity\": $util.toJson($ctx.identity),\n      \"source\": $util.toJson($ctx.source),\n      \"request\": $util.toJson($ctx.request),\n      \"prev\": $util.toJson($ctx.prev)\n  }\n}\n## [End] Invoke AWS Lambda data source: HelloWorldLambdaDataSource. **",
    "InvokeHelloWorldLambdaDataSource.res.vtl": "## [Start] Handle error or return result. **\n#if( $ctx.error )\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n$util.toJson($ctx.result)\n## [End] Handle error or return result. **",
    "InvokeGoodByeWorldLambdaDataSource.req.vtl": "## [Start] Invoke AWS Lambda data source: GoodByeWorldLambdaDataSource. **\n{\n  \"version\": \"2018-05-29\",\n  \"operation\": \"Invoke\",\n  \"payload\": {\n      \"typeName\": \"$ctx.stash.get(\"typeName\")\",\n      \"fieldName\": \"$ctx.stash.get(\"fieldName\")\",\n      \"arguments\": $util.toJson($ctx.arguments),\n      \"identity\": $util.toJson($ctx.identity),\n      \"source\": $util.toJson($ctx.source),\n      \"request\": $util.toJson($ctx.request),\n      \"prev\": $util.toJson($ctx.prev)\n  }\n}\n## [End] Invoke AWS Lambda data source: GoodByeWorldLambdaDataSource. **",
    "InvokeGoodByeWorldLambdaDataSource.res.vtl": "## [Start] Handle error or return result. **\n#if( $ctx.error )\n  $util.error($ctx.error.message, $ctx.error.type)\n#end\n$util.toJson($ctx.result)\n## [End] Handle error or return result. **"
  },
  "schema": "type Blog {\n  blogId: String!\n  name: String!\n  createdAt: AWSDateTime!\n  updatedAt: AWSDateTime!\n}\n\ntype BlogPost {\n  blogId: String!\n  blogPostId: String!\n  title: String!\n  body: String!\n  createdAt: AWSDateTime!\n  updatedAt: AWSDateTime!\n}\n\ntype Comment {\n  blogPostId: String!\n  commentId: String!\n  body: String!\n  publishDate: Int!\n  createdAt: AWSDateTime!\n  updatedAt: AWSDateTime!\n}\n\ntype TagCloud {\n  size: Int!\n  tag: String!\n}\n\ntype Query {\n  helloWorld(blogId: String!): String\n  getBlog(blogId: String!): Blog\n  listBlogs(blogId: String, filter: ModelBlogFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelBlogConnection\n  getBlogPost(blogId: String!, blogPostId: String!): BlogPost\n  listBlogPosts(blogId: String, blogPostId: ModelStringKeyConditionInput, filter: ModelBlogPostFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelBlogPostConnection\n  getComment(blogPostId: String!, commentId: String!): Comment\n  listComments(blogPostId: String, commentId: ModelStringKeyConditionInput, filter: ModelCommentFilterInput, limit: Int, nextToken: String, sortDirection: ModelSortDirection): ModelCommentConnection\n}\n\ntype Mutation {\n  goodByeWorld(blogId: String!): String\n  createBlog(input: CreateBlogInput!): Blog\n  updateBlog(input: UpdateBlogInput!): Blog\n  deleteBlog(input: DeleteBlogInput!): Blog\n  createBlogPost(input: CreateBlogPostInput!): BlogPost\n  updateBlogPost(input: UpdateBlogPostInput!): BlogPost\n  deleteBlogPost(input: DeleteBlogPostInput!): BlogPost\n  createComment(input: CreateCommentInput!): Comment\n  updateComment(input: UpdateCommentInput!): Comment\n  deleteComment(input: DeleteCommentInput!): Comment\n}\n\nenum ModelSortDirection {\n  ASC\n  DESC\n}\n\ntype ModelBlogConnection {\n  items: [Blog]\n  nextToken: String\n}\n\ninput ModelStringFilterInput {\n  ne: String\n  eq: String\n  le: String\n  lt: String\n  ge: String\n  gt: String\n  contains: String\n  notContains: String\n  between: [String]\n  beginsWith: String\n}\n\ninput ModelIDFilterInput {\n  ne: ID\n  eq: ID\n  le: ID\n  lt: ID\n  ge: ID\n  gt: ID\n  contains: ID\n  notContains: ID\n  between: [ID]\n  beginsWith: ID\n}\n\ninput ModelIntFilterInput {\n  ne: Int\n  eq: Int\n  le: Int\n  lt: Int\n  ge: Int\n  gt: Int\n  between: [Int]\n}\n\ninput ModelFloatFilterInput {\n  ne: Float\n  eq: Float\n  le: Float\n  lt: Float\n  ge: Float\n  gt: Float\n  between: [Float]\n}\n\ninput ModelBooleanFilterInput {\n  ne: Boolean\n  eq: Boolean\n}\n\ninput ModelBlogFilterInput {\n  blogId: ModelStringFilterInput\n  name: ModelStringFilterInput\n  and: [ModelBlogFilterInput]\n  or: [ModelBlogFilterInput]\n  not: ModelBlogFilterInput\n}\n\ninput CreateBlogInput {\n  blogId: String!\n  name: String!\n}\n\ninput UpdateBlogInput {\n  blogId: String!\n  name: String\n}\n\ninput DeleteBlogInput {\n  blogId: String!\n}\n\ntype Subscription {\n  onCreateBlog: Blog @aws_subscribe(mutations: [\"createBlog\"])\n  onUpdateBlog: Blog @aws_subscribe(mutations: [\"updateBlog\"])\n  onDeleteBlog: Blog @aws_subscribe(mutations: [\"deleteBlog\"])\n  onCreateBlogPost: BlogPost @aws_subscribe(mutations: [\"createBlogPost\"])\n  onUpdateBlogPost: BlogPost @aws_subscribe(mutations: [\"updateBlogPost\"])\n  onDeleteBlogPost: BlogPost @aws_subscribe(mutations: [\"deleteBlogPost\"])\n  onCreateComment: Comment @aws_subscribe(mutations: [\"createComment\"])\n  onUpdateComment: Comment @aws_subscribe(mutations: [\"updateComment\"])\n  onDeleteComment: Comment @aws_subscribe(mutations: [\"deleteComment\"])\n}\n\ntype ModelBlogPostConnection {\n  items: [BlogPost]\n  nextToken: String\n}\n\ninput ModelBlogPostFilterInput {\n  blogId: ModelStringFilterInput\n  blogPostId: ModelStringFilterInput\n  title: ModelStringFilterInput\n  body: ModelStringFilterInput\n  and: [ModelBlogPostFilterInput]\n  or: [ModelBlogPostFilterInput]\n  not: ModelBlogPostFilterInput\n}\n\ninput CreateBlogPostInput {\n  blogId: String!\n  blogPostId: String!\n  title: String!\n  body: String!\n}\n\ninput UpdateBlogPostInput {\n  blogId: String!\n  blogPostId: String!\n  title: String\n  body: String\n}\n\ninput DeleteBlogPostInput {\n  blogId: String!\n  blogPostId: String!\n}\n\ntype ModelCommentConnection {\n  items: [Comment]\n  nextToken: String\n}\n\ninput ModelCommentFilterInput {\n  blogPostId: ModelStringFilterInput\n  commentId: ModelStringFilterInput\n  body: ModelStringFilterInput\n  publishDate: ModelIntFilterInput\n  and: [ModelCommentFilterInput]\n  or: [ModelCommentFilterInput]\n  not: ModelCommentFilterInput\n}\n\ninput CreateCommentInput {\n  blogPostId: String!\n  commentId: String!\n  body: String!\n  publishDate: Int!\n}\n\ninput UpdateCommentInput {\n  blogPostId: String!\n  commentId: String!\n  body: String\n  publishDate: Int\n}\n\ninput DeleteCommentInput {\n  blogPostId: String!\n  commentId: String!\n}\n\ninput ModelStringKeyConditionInput {\n  eq: String\n  le: String\n  lt: String\n  ge: String\n  gt: String\n  between: [String]\n  beginsWith: String\n}\n"
}